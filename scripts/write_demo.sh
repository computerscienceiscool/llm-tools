#!/bin/bash

# Change to project root directory
cd "$(dirname "$0")/.."

# Demo script for testing LLM File Access Tool write functionality

echo "=== LLM File Access Tool - Write Command Demo ==="
echo

# Create a temporary demo repository
DEMO_DIR=$(mktemp -d)
echo "Creating demo repository at: $DEMO_DIR"

# Create some initial files
mkdir -p "$DEMO_DIR/src"
mkdir -p "$DEMO_DIR/docs"

cat > "$DEMO_DIR/README.md" << 'EOF'
# Demo Project

This is a demonstration repository for the LLM File Access Tool.
We will test both reading and writing capabilities.
EOF

cat > "$DEMO_DIR/src/hello.go" << 'EOF'
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
EOF

echo "Demo repository created with initial files."
echo "Building the tool..."

# Build the tool if not already built
if [ ! -f "./llm-tool" ]; then
    go build -o llm-tool main.go
fi

echo
echo "=== Demo 1: Create a new file ==="
echo "Testing: Create a new configuration file"
echo "---"

cat << 'EOF' | ./llm-tool --root "$DEMO_DIR" --verbose
I need to create a configuration file for this project.

<write config.yaml>
# Project Configuration
name: demo-project
version: 1.0.0
author: LLM Tool Demo

build:
  target: ./bin/demo
  source: ./src

dependencies:
  - fmt
  
settings:
  debug: true
  port: 8080
</write>

The configuration file has been created successfully.
EOF

echo
echo "=== Demo 2: Update an existing file ==="
echo "Testing: Update the README with more content"
echo "---"

cat << 'EOF' | ./llm-tool --root "$DEMO_DIR" --verbose
Let me first read the current README to understand it:

<open README.md>

Now I'll enhance it with more detailed information:

<write README.md>
# Demo Project

This is a demonstration repository for the LLM File Access Tool.
We will test both reading and writing capabilities.

## Features

- File reading with `<open filename>` commands
- File writing with `<write filename>content</write>` commands  
- Security validation to prevent path traversal
- Automatic backup creation before overwrites
- Content formatting for supported file types

## Project Structure

```
demo-project/
├── README.md          # This file
├── config.yaml        # Project configuration  
├── src/               # Source code
│   └── hello.go       # Main application
└── docs/              # Documentation
```

## Getting Started

1. Read the configuration: `<open config.yaml>`
2. Run the application: `go run src/hello.go`

Generated by LLM File Access Tool
</write>

README has been successfully updated with comprehensive information.
EOF

echo
echo "=== Demo 3: Create multiple related files ==="
echo "Testing: Create documentation and test files"
echo "---"

cat << 'EOF' | ./llm-tool --root "$DEMO_DIR" --verbose
I'll create comprehensive documentation and test files for this project.

First, let's create a proper Go module:

<write go.mod>
module demo-project

go 1.21

require ()
</write>

Now create a test file for the main package:

<write src/hello_test.go>
package main

import (
    "testing"
    "os"
    "os/exec"
)

func TestMain(t *testing.T) {
    // Test that the main function doesn't panic
    // This is a basic smoke test
    
    if os.Getenv("BE_MAIN") == "1" {
        main()
        return
    }
    
    cmd := exec.Command(os.Args[0], "-test.run=TestMain")
    cmd.Env = append(os.Environ(), "BE_MAIN=1")
    err := cmd.Run()
    if err != nil {
        t.Fatalf("Main function failed: %v", err)
    }
}

func TestHelloFunction(t *testing.T) {
    // Since main() just prints, we'll test that it doesn't crash
    // In a real project, we'd extract printable functions to test
    t.Log("Main function exists and can be called")
}
</write>

Create documentation for the API:

<write docs/API.md>
# API Documentation

## Overview

This is a simple Hello World application demonstrating Go development practices.

## Functions

### main()

**Description:** Entry point of the application. Prints "Hello, World!" to stdout.

**Parameters:** None

**Returns:** None

**Example:**
```bash
$ go run src/hello.go
Hello, World!
```

## Testing

Run tests with:
```bash
go test ./src
```

## Building

Build the application:
```bash
go build -o bin/hello src/hello.go
```
</write>

Finally, create a simple Makefile:

<write Makefile>
# Demo Project Makefile

.PHONY: build test run clean

# Build the application
build:
	@echo "Building application..."
	@mkdir -p bin
	@go build -o bin/hello src/hello.go
	@echo "Build complete: bin/hello"

# Run tests
test:
	@echo "Running tests..."
	@go test ./src

# Run the application
run: build
	@echo "Running application..."
	@./bin/hello

# Clean build artifacts
clean:
	@echo "Cleaning..."
	@rm -rf bin/
	@echo "Clean complete"

# Install dependencies
deps:
	@echo "Installing dependencies..."
	@go mod download

help:
	@echo "Available targets:"
	@echo "  build  - Build the application"
	@echo "  test   - Run tests"  
	@echo "  run    - Build and run the application"
	@echo "  clean  - Remove build artifacts"
	@echo "  deps   - Install dependencies"
	@echo "  help   - Show this help"
</write>

All project files have been created successfully! The demo project now has:
- Go module definition
- Test coverage
- Documentation
- Build automation
EOF

echo
echo "=== Demo 4: Test backup functionality ==="
echo "Testing: Modify a file multiple times to see backups"
echo "---"

cat << 'EOF' | ./llm-tool --root "$DEMO_DIR" --verbose --backup
Let me modify the hello.go file to demonstrate backup functionality:

<write src/hello.go>
package main

import "fmt"

func main() {
    fmt.Println("Hello, LLM World!")
    fmt.Println("This file has been updated by the LLM tool")
}
</write>

Now let me update it again to show multiple backups:

<write src/hello.go>
package main

import (
    "fmt" 
    "time"
)

func main() {
    fmt.Println("Hello, LLM World!")
    fmt.Println("This file has been updated by the LLM tool")
    fmt.Printf("Current time: %s\n", time.Now().Format("2006-01-02 15:04:05"))
}
</write>
EOF

echo
echo "=== Demo 5: Error handling ==="
echo "Testing: Various error conditions"
echo "---"

cat << 'EOF' | ./llm-tool --root "$DEMO_DIR" --verbose
Let me test various error conditions:

Try to write to a forbidden extension:

<write malicious.exe>
This should be rejected due to extension filtering
</write>

Try to write outside the repository:

<write ../../../etc/evil.txt>
This should be rejected due to path traversal protection  
</write>

Try to write a very large file (this might succeed depending on limits):

<write large.txt>
This is a test of size limits. In a real scenario, this would be much larger content that exceeds the configured maximum write size limit. The tool should reject files that are too large to prevent abuse and resource exhaustion.
</write>
EOF

echo
echo "=== Demo Results ==="
echo "Let's examine what was created:"
echo

echo "Files in demo directory:"
find "$DEMO_DIR" -type f | sort

echo
echo "Backup files (if any):"
find "$DEMO_DIR" -name "*.bak.*" | sort

echo  
echo "Checking audit log:"
if [ -f "audit.log" ]; then
    echo "Recent audit entries:"
    tail -10 audit.log
else
    echo "No audit log found"
fi

echo
echo "=== File Contents ==="
echo

echo "config.yaml:"
cat "$DEMO_DIR/config.yaml" 2>/dev/null || echo "File not found"

echo
echo "Updated README.md:"
head -20 "$DEMO_DIR/README.md" 2>/dev/null || echo "File not found" 

echo
echo "go.mod:"
cat "$DEMO_DIR/go.mod" 2>/dev/null || echo "File not found"

echo
echo "=== Cleanup ==="
echo "Demo directory: $DEMO_DIR"
echo "To clean up manually: rm -rf $DEMO_DIR"

echo
echo "Write command demo complete!"
echo
echo "Key features demonstrated:"
echo "- Creating new files with proper content"
echo "- Updating existing files with backups"
echo "- Multiple file operations in sequence"
echo "- Security validation (extension and path checks)"
echo "- Atomic writes with temporary files"
echo "- Audit logging of all operations"
echo "- Content formatting (Go, YAML, Markdown)"
